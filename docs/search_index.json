[["index.html", "[UST 2021] 데이터 사이언스를 위한 R 프로그래밍 1 Introduction 강의 개요 1.1 Goal 강의 목표 1.2 This course 1.3 Tips 1.4 References books 주요/참고 교제 1.5 References 참고 자료 1.6 Evaluation 평가 세부 항목 1.7 Schedule 강의 계획 1.8 R Lecture Youtube Link", " [UST 2021] 데이터 사이언스를 위한 R 프로그래밍 한국생명공학연구원 김하성 2021-03-25 1 Introduction 강의 개요 매주 목요일 강의노트, 동영상 업데이트 강사: 한국생명공학연구원 바이오합성연구센터 김하성 연락처: 042-860-4372, haseong [at] kribb.re.kr (생명연 연구동 1143) 강의조교: 박성군, tjdrns27 [at] kribb.re.kr 강의site: https://greendaygh.github.io/Rprog2021/ 1.1 Goal 강의 목표 이공계열 대학원생이 그들의 원활한 실험 설계와 데이터 분석을 위해 범용 프로그램 언어인 R의 사용법과 프로그래밍 기술을 습득할수 있도록 하는데 목표가 있음. 특히 Data scientist를 위해 개발된 tidyverse 패키지 위주의 강의를 진행함. 1.2 This course 이 강좌는 온라인 (강의자료, 동영상) 강의를 기본으로 함 R에 대한 기본 개념과 사용법, 데이터분석 중심의 설명, 필요시 기초 통계 지식 강의 매회 강의에는 해당 강의 내용과 관련된 과제가 주어지며 이메일을 통해 문제 풀이를 제출받음 상황에 따라 강의자료 및 동영상 업데이트 일정이 조정될 수 있음 참고 온라인 강의 특성상 스스로 학습하려는 의지가 강하지 않으면 효과가 없습니다. 매시간 작은 것이라도 배워간다는 마음으로 강의에 임해주시기 바랍니다 1.3 Tips 눈으로 이해하지 않고 스스로 실습 필수 각 명령줄이 어떻게/왜 작동하는지 이해하기 인터넷 검색을 통한 다른사람의 코드 이해/적용 필요 1.4 References books 주요/참고 교제 R for Data Science (https://r4ds.had.co.nz, https://github.com/hadley) Hands-On Programming with R (https://rstudio-education.github.io/hopr/) Using R for Introductory Statistics by John Verzani Free version of 1st Edition https://cran.r-project.org/doc/contrib/Verzani-SimpleR.pdf Second edition https://www.crcpress.com/Using-R-for-Introductory-Statistics-Second-Edition/Verzani/p/book/9781466590731 Bioinformatics Data Skills by Vince Buffalo (http://2.droppdf.com/files/5aTvl/bioinformatics-data-skills.pdf) First Course in Statistical Programming with R by Braun and Murdoch (https://www.cambridge.org/core/books/first-course-in-statistical-programming-with-r/C9F088122AB40517B07FA77F2F0FDE2F) Introductory Statistics with R by Dalgaard (http://www.academia.dk/BiologiskAntropologi/Epidemiologi/PDF/Introductory_Statistics_with_R__2nd_ed.pdf) Modern Applied Statistics with S by Venables and Ripley (http://www.bagualu.net/wordpress/wp-content/uploads/2015/10/Modern_Applied_Statistics_With_S.pdf) 일반통계학 (영지문화사, 김우철 외) 1.5 References 참고 자료 https://resources.rstudio.com/ http://shiny.rstudio.com/tutorial/ R 홈페이지 https://www.r-project.org/ Rstudio 홈페이지 https://www.rstudio.com/ Packages for biologists https://www.bioconductor.org/ R 기본 문서들 (소개, 사용, 설치, 운영) https://cran.r-project.org/manuals.html R ebooks https://bookdown.org/ Cheat Sheets https://www.rstudio.com/resources/cheatsheets/ 1.6 Evaluation 평가 세부 항목 과제 100% 성적부여기준: 최종 평균균 70점 이상 S, 70점 미만 U 부여 과제 채점: 각 과제당 총점 100점 만점 환산 점수 (답이 틀려도 코드가 있으면 가산점) 과제 제출일: 수업 자료 배포 후 1주일 (목요일 강의 자료 배포 -&gt; 그 다음주 목요일 까지) 과제 솔루션 배포: 과제 제출일 마감 이 후 조교 배포 감점 기준 과제 제출일 (1주) 이내 제출: 감점 없음 과제 제출일 (1주) 이후 제출: 20점 감점 솔루션 배포 이후 과제 제출: 40점 감점 과제 미제출: 100점 감점 참고로 S/U 판단은 최종 평가시 평균 70정으로 진행행 1.7 Schedule 강의 계획 1주차 - Introduction and installation of R/Rstudio 2주차 - R language basics I - Objects 3주차 - R language basics II - Objects 4주차 - R language basics III - Programming 5주차 - R language basics IV - Programming 6주차 - Visualizing data I - Basics 7주차 - Visualizing data II - ggplot2 8주차 - Visualizing data III - ggplot2 9주차 - Data transformation I - Basics 10주차 - Data transformation II - dplyr 11주차 - Data transformation III - dplyr 12주차 - Data analysis example 13주차 - Shiny for interactive applications in R I 14주차 - Shiny for interactive applications in R II 15주차 - Shiny application example 16주차 - R Markdown with Rstudio 1.8 R Lecture Youtube Link 1.8.1 Lecture 1 https://youtu.be/wlzwYtHu2xA 1.8.2 Lecture 2 https://youtu.be/bdYGNQybmX8 1.8.3 Lecture 3 https://youtu.be/jYg88NoRc0A 1.8.4 Lecture 4 1.8.5 Lecture 5 1.8.6 Lecture 6 1.8.7 Lecture 7 "],["introduction-and-installation-of-rrstudio.html", "2 Introduction and installation of R/Rstudio 2.1 What is R / Rstudio 2.2 R installation 2.3 Rstudio installation 2.4 Rstudio interface 2.5 New file &amp; Set working directory 2.6 New project 2.7 Keyboard shortcuts 2.8 Hello world 2.9 Help 2.10 R packages 2.11 Data sets 2.12 Cheatsheet", " 2 Introduction and installation of R/Rstudio https://youtu.be/wlzwYtHu2xA 2.1 What is R / Rstudio R은 통계나 생물통계, 유전학을 연구하는 사람들 사이에서 널리 사용되는 오픈소스 프로그래밍 언어 입니다. Bell Lab에서 개발한 S 언어에서 유래했으며 엄청나게 많은 라이브러리 (다른 사람들이 만들어 놓은 코드)가 있어서 쉽게 가져다 사용할 수 있습니다. R은 복잡한 수식이나 통계 알고리즘을 간단히 구현하고 사용할 수 있으며 C, C++, Python 등 다른 언어들과의 병행 사용도 가능합니다. R은 IEEE에서 조사하는 Top programming languages에서 2018년 7위, 2019년 5위, 2020년 6위로 꾸준히 높은 사용자를 확보하며 빅데이터, AI 시대의 주요한 프로그래밍 언어로 사용되고 있습니다. https://spectrum.ieee.org/computing/software/ R은 데이터를 통계분석에 널리 사용되는데 이는 데이터를 눈으로 확인하기 위한 visualization 이나 벡터 연산 등의 강력한 기능 때문에 점점 더 많은 사람들이 사용하고 있습니다. 기존에는 속도나 확장성이 다른 언어들에 비해 단점으로 지적되었으나 R 언어의 계속적인 개발과 업데이트로 이러한 단점들이 빠르게 보완되고 있습니다. R 사용을 위해서는 R 언어의 코어 프로그램을 먼저 설치하고 그 다음 R 언어용 IDE(Integrated Development Environment)인 RStudio 설치가 필요합니다. 2.2 R installation R (https://www.r-project.org/) 사이트에 접속 후 좌측 메뉴 상단에 위치한 CRAN 클릭. 미러 사이트 목록에서 Korea의 아무 사이트나 들어감 Download R for Windows를 (windows OS의 경우) 클릭 base 링크 또는 install R for the first time 클릭 Download R 4.0.4 for Windows 링크로 실행 프로그램 다운로드 (2021.3 현재 R 버전은 4.0.4). 로컬 컴퓨터에 Download 된 R-4.0.4-win.exe 를 실행하고 설치 프로그램의 지시에 따라 R 언어 소프트웨어 설치를 완료합니다. 2.3 Rstudio installation Rstudio는 R 언어를 위한 오픈소스 기반 통합개발환경(IDE)으로 R 프로그래밍을 위한 편리한 기능들을 제공해 줍니다. R언어가 주목을 받고 두터운 사용자 층을 확보할 수 있게된 핵심 동력이 Rstudio 입니다. 자체적으로 오픈소스 개발팀이 있으며 dplyr, ggplot, shiny 등의 데이터 분석 및 소통을 위한 주요 패키지를 개발하였고 정기적으로 conference 개최를 하면서 기술 보급의 핵심 역할을 하고 있습니다. 다음과 같은 방법으로 RStudio를 설치할 수 있습니다. https://www.rstudio.com/ 접속, 상단의 Products &gt; RStudio 클릭 RStudio 페이지로 이동동 하단 RStudio Desktop 선택 Open Source Edition의 Download RStudio Desktop 클릭 하단 DOWNLOAD RSTUDIO FOR WINDOWS 클릭 2021.03현재 version 1.4.1106, 로컬 컴퓨터에 다운로드된 RStudio-1.4.1106.exe를 실행하고 설치 가이드에 따라 설치 완료합니다. 2.4 Rstudio interface 아래 그림의 좌측 상단의 공간은 코드편집창, 좌측 하단은 콘솔창 입니다. 2.5 New file &amp; Set working directory 새로운 R 파일 (또는 다른 형태의 파일)은 File &gt; New File &gt; R Script 의 메뉴를 통해서 생성할 수 있습니다. 일반적으로 이렇게 새로운 파일을 만들고 코드를 작성하기 전에 해당 작업을 수행하기 위한 작업 디렉토리를 설정할 필요가 있습니다. getwd() dir() setwd(&quot;C:\\\\rprog2021&quot;) getwd() dir() 또는 아래와 같이 RStudio 메뉴 에서 설정 2.6 New project 위와 같이 파일을 만들고 작업 디렉토리를 설정하는 것보다 프로젝트를 만들고 파일들을 관리하는 것이 여러모로 편리할 때가 많습니다. File &gt; New Project를 선택하면 아래와 같은 팝업창이 나타납니다. 여기서 New Directory를 선택하고 (또는 기존 디렉토리가 있을 경우 Existing Directory 선택) New Project를 클릭하면 다음과 같이 디렉토리 이름과 디렉토리가 생성될 위치를 지정할 수 있습니다. 이름은 Rprog2021로 하고 C:/mydocs/2021/dev/ 이 곳에 생성되도록 하겠습니다. 그럼 아래와 같이 새로운 디렉토리가 생성되며 Rprog2021.Rproj 파일이 생성됩니다. 이제 언제든 해당 프로젝트를 작업할 때 이 Proj 파일을 실행하면 RStudio가 실행되고 최종 작업했던 상태에서 시작하게 됩니다. 작업 디렉토리 역시 Proj 파일이 위치한 디렉토리 위치로 자동으로 설정 됩니다. 2.7 Keyboard shortcuts 참고사이트 https://support.rstudio.com/hc/en-us/articles/200711853-Keyboard-Shortcuts Tools –&gt; Keyboard shortcut Quick Reference (Alt + Shift + K) 코드편집창 이동 (Ctrl+1) 콘솔창 이동(Ctrl+2) 한 줄 실행 (Ctrl+Enter) 주석처리 (Ctrl + Shift + C) 또는 #으로 시작하는 라인 실습 코드편집창에서 다음 입력 단축키 Ctrl + enter로 코드 실행 단축키 Ctrl + 2로 커서 콘솔창으로 이동 x값 x+y값 확인 단축키 Ctrl + 1로 코드편집창 이동 단축키 Ctrl + Shift + C 사용 # x &lt;- 10 # y &lt;- 20 2.8 Hello world mystring &lt;- &quot;Hello \\n world!&quot; cat(mystring) print(mystring) 2.9 Help R의 장점 중 하나로 방대한 양의 도움말 페이지가 제공됩니다. ? 명령을 사용하면 되며 구글이나 웹에서도 도움을 얻을 수 있습니다. ?cat ?print ?mean help(&quot;mean&quot;) example(&quot;mean&quot;) help.search(&quot;mean&quot;) help(package=&quot;MASS&quot;) 2.10 R packages R은 package라 불리는 다양한 함수 라이브러리를 사용할 수 있습니다. 예를 들어 sum() 이나 sd()와 같은 함수는 stats이라는 패키지에서 구현된 함수 입니다. stats 패키지는 R이나 Rstudio를 실행할 경우 기본으로 불려지는 패키지로서 별도로 불러오는 과정이 필요하지 않습니다. 이러한 패키지는 인터넷의 repository에서 구할 수 있으며 대표적인 repository는 The Comprehensive R Archive Network (CRAN) (http://cran.r-project.org/web/views/) 와 생물학자를 위한 Bioconductor (http://www.bioconductor.org/) 가 있습니다. 이러한 패키지의 설치는 아래와 같이 RStudio를 이용하거나 콘솔창에서 install.packages() 함수를 이용할 수 있습니다. UsingR package installation 패키지를 설치하고 사용하기 위해서는 library() 함수를 사용해서 관련 명령어를 사용하기 전에 미리 loading 해 두어야 합니다. 한 번 로딩으로 작업 세션이 끝날때까지 관련된 함수를 사용할 수 있으나 R 세션이나 RStudio를 재시작 할 경우 다시 로딩해야 사용할 수 있습니다. library(UsingR) R 설치 디렉토리 R 패키지 설치 디렉토리 .libPaths() path.package() 2.11 Data sets 대부분의 패키지는 함수와 함께 관련된 도움말, 예제, 그리고 데이터셋을 같이 제공해 줍니다. library() 함수를 사용할 때 자동으로 같이 로딩이 되며 data() 함수를 사용해서 사용자 작업공간에 복사본을 만들어서 사용할 수 있습니다. head(rivers) length(rivers) class(rivers) data(rivers) data(package=&quot;UsingR&quot;) library(HistData) head(Cavendish) str(Cavendish) head(Cavendish$density2) data(package=&quot;HistData&quot;) 2.12 Cheatsheet 이 저작물은 크리에이티브 커먼즈 저작자표시-비영리-변경금지 4.0 국제 라이선스에 따라 이용할 수 있습니다. "],["r-language-basics-i-objects.html", "3 R language basics I - Objects 3.1 Terminology 3.2 R console script 3.3 What is a programming language 3.4 Variables and values 3.5 Object - Vectors 3.6 Object - matrix 3.7 Object - data.frame 3.8 Object - list 3.9 Missing values 3.10 Useful functions I", " 3 R language basics I - Objects https://youtu.be/bdYGNQybmX8 3.1 Terminology Session: R 언어 실행 환경 Console: 명령어 입력하는 창 Code: R 프로그래밍 변수/제어문 모음 Object types: vector: 값들의 모임 combine function c() EX: c(6, 11, 13, 31, 90, 92) matrix: 2D 형태 값들의 모임 array: 1D, 2D, 3D, … 형태 값들의 모임 factor: 범주형 데이터 data frame: 2D 형태 값들의 모임 (다른 타입 값 가능) list: function: 특정 기능 수행, [함수이름, 입력값 (arguments), 출력값 (return)] 으로 구성 Data (value) types: Integers doubles/numerics logicals characters. Conditionals (조건, 제어): if, ==, &amp; (AND), | (OR) Ex: (2 + 1 == 3) &amp; (2 + 1 == 4) for, while: 반복 수 3.2 R console script 콘솔에서 바로 계산을 수행할 수 있습니다. 참고로 이전에 수행한 명령은 콘솔에 커서가 있는 상태에서 위 아래 화살표를 누르면 볼 수 있고 엔터를 눌러 재사용 할 수 있습니다. ;을 사용하면 두 개의 명령을 동시에 수행할 수 있습니다. \\[ 2 + 2 \\] \\[ ((2 - 1)^2 + (1 - 3)^2)^{1/2} \\] 2 + 2 ((2 – 1)^2 + (1 – 3)^2 )^(1/2) 2 + 2; 2 - 2 3.3 What is a programming language 3.4 Variables and values R is a programming language Assignment operator ( &lt;- OR = ) Valid object name &lt;- value 단축키: Alt + - (the minus sign) 내장 변수 Built-in variables x &lt;- 2 y &lt;- x^2 – 2*x + 1 y x &lt;- &quot;two&quot; some_data &lt;- 9.8 pi 변수이름 작명법 Characters (letters), numbers, “_”, “.” A and a are different symbols Names are effectively unlimited in length i_use_snake_case &lt;- 1 otherPeopleUseCamelCase &lt;- 2 some.people.use.periods &lt;- 3 And_aFew.People_RENOUNCEconvention &lt;- 4 자동 완성 기능 (Tab completion) in RStudio 3.5 Object - Vectors vector는 R의 기본 데이터 구조입니다. numeric vector, logical vector, character vector 등 저장되는 값의 타입에 따라 크게 세가지로 나눌 수 있습니다. class() 함수를 이용해서 값의 타입을 알아낼 수 있습니다. Combine function인 c()를 활용하여 만들며 값을 순차적으로 붙여갈 수 있습니다. x &lt;- c(10.4, 5.6, 3.1, 6.4, 21.7) class(x) y &lt;- c(&quot;X1&quot;, &quot;Y2&quot;, &quot;X3&quot;, &quot;Y4&quot;) class(y) z &lt;- c(T, F, F, T) class(z) 3.5.1 Numeric 이 중 특히 numeric 형식의 벡터를 만드는 다양한 편의 함수들이 존재합니다. 1:5 seq(1,5, by=1) seq(0, 100, by=10) seq(0, 100, length.out=11) ?seq rep(5, times=10) rep(1:3, times=4) rep(1:3, each=3) 3.5.1.1 Exercise 3-1 odds라는 이름의 변수에 1부터 100까지의 홀수만을 저장하시오 (seq() 함수 사용) 3.5.2 Logical Logical 벡터는 True 또는 False를 원소로 갖는 벡터 입니다. 앞글자가 대분자로 시작하는 것을 기억하시고 T 또는 F와 같이 한 문자로 표현할 수도 있습니다. 특정 조건에 대한 판단 결과를 반환할 경우에도 논리값을 사용합니다. 이 경우 조건을 판단 후 인덱싱 방법으로 해당 값들을 뽑아내기도 합니다. is.na(1) is.numeric(1) is.logical(TRUE) x &lt;- 1:20 x &gt; 13 temp &lt;- x &gt; 13 class(temp) ages &lt;- c(66, 57, 60, 41, 6, 85, 48, 34, 61, 12) ages &lt; 30 which(ages &lt; 30) i &lt;- which(ages &lt; 30) ages[i] any(ages &lt; 30) all(ages &lt; 30) 3.5.2.1 Exercise 3-2 1부터 100까지의 수를 n이라는 이름의 변수에 저장하고 이 중 짝수만을 뽑아내서 출력하시오 (which()함수 사용) 3.5.3 Character Character(문자형) 벡터의 경우 문자열을 다루는데 자주 쓰이는 paste() 함수의 사용법을 알아두면 편리합니다. paste() 함수는 서로 다른 문자열을 붙이는데 주로 사용됩니다. 참고로 문자열을 나누는 함수는 strsplit() 입니다. paste()에서 붙이는 문자 사이에 들어가는 문자를 지정하는 파라메터는 sep 이고 strsplit()함수에서 자르는 기준이 되는 문자는split 파라메터로 지정해 줍니다 (?split 또는 ?paste 확인). paste(&quot;X&quot;, &quot;Y&quot;, &quot;Z&quot;, sep=&quot;_&quot;) paste(c(&quot;Four&quot;,&quot;The&quot;), c(&quot;Score&quot;,&quot;quick&quot;), c(&quot;and&quot;,&quot;fox&quot;), sep=&quot;_&quot;) paste(&quot;X&quot;, 1:5, sep=&quot;&quot;) paste(c(&quot;X&quot;,&quot;Y&quot;), 1:10, sep=&quot;&quot;) x &lt;- c(&quot;X1&quot;, &quot;Y2&quot;, &quot;X3&quot;, &quot;Y4&quot;, &quot;X5&quot;) paste(x[1], x[2]) paste(x[1], x[2], sep=&quot;&quot;) paste(x, collapse=&quot;_&quot;) strsplit(&quot;XYZ&quot;, split=&quot;&quot;) 3.5.3.1 Exercise 3-3 m이라는 변수에 “Capital of South Korea is Seoul” 문자열을 저장하고 “Capital of South Korea”를 따로 뽑아내 m2에 저장하시오 (substr() 사용) 3.5.4 Factor Factor형은 범주형데이터를 저장하기 위한 object 이며 R 언어에서 특별히 만들어져 사용되고 있습니다. factor() 함수를 이용해 생성하며 생성된 객체는 다음과 같이 level이라는 범주를 나타내는 특성값을 가지고 있습니다. x &lt;- c(&quot;Red&quot;, &quot;Blue&quot;, &quot;Yellow&quot;, &quot;Green&quot;, &quot;Blue&quot;, &quot;Green&quot;) y &lt;- factor(x) y 새로운 범주의 데이터를 추가할 경우 다음과 같이 해당되는 level을 먼저 추가하고 값을 저장해야 합니다. levels(y) y[1] &lt;- &quot;Gold&quot; y levels(y) &lt;- c(levels(y), &quot;Gold&quot;) levels(y) y y[1] &lt;- &quot;Gold&quot; y factor는 기본적으로 level에 표시된 순서가 위치 (정렬) 순서입니다. 이를 바꾸기 위해서는 다음과 같이 levels 함수를 이용해서 순서를 바꿀 수 있습니다. #library(UsingR) str(Cars93) x &lt;- Cars93$Origin plot(x) levels(x) &lt;- c(&quot;non-USA&quot;, &quot;USA&quot;) levels(x) plot(x) 3.5.5 Attribute vector 들은 다음과 같은 builtin 함수들을 사용해서 해당 변수의 attribute를 알아낼 수 있습니다. attribute에는 원소 이름, 타입, 길이 등 vector형 변수가 가질 수 있는 특성을 말합니다. head(precip) class(precip) length(precip) names(precip) test_scores &lt;- c(100, 90, 80) names(test_scores) &lt;- c(&quot;Alice&quot;, &quot;Bob&quot;, &quot;Shirley&quot;) test_scores 3.5.6 Indexing 인덱싱은 vector 데이터의 일부 데이터를 참조할 때 사용하는 방법입니다. x[1] x[1:3] i &lt;- 1:3 x[i] x[c(1,2,4)] y[3] head(precip) precip[1] precip[2:10] precip[c(1,3,5)] precip[-1] precip[&quot;Seattle Tacoma&quot;] precip[c(&quot;Seattle Tacoma&quot;, &quot;Portland&quot;)] precip[2] &lt;- 10 3.6 Object - matrix 매트릭스는 2차원 행렬로 같은 형식의 데이터 값 (numberic, character, logical) 으로만 채워진 행렬을 말합니다. 메트릭스를 만드는 방법은 아래와 같으며 nrow 와 ncol 파라메터에 행과 열의 수를 넣고 각 셀에 들어갈 값은 가장 앞에 위치한 data 파라메터에 넣어 줍니다 (?matrix로 파라메터 이름 확인). 메트릭스 인덱싱은 메트릭스 안의 값을 저장하거나 참조할때 (빼올때) 사용하는 방법입니다. 메트릭스 변수이름 바로 뒤에 대괄호를 이용해서 제어를 하며 대괄호 안에 콤마로 구분된 앞쪽은 row, 뒷쪽은 column 인덱스를 나타냅니다. mymat &lt;- matrix(0, nrow=100, ncol=3) # 1 mymat[,1] &lt;- 1:100 # 2 mymat[,2] &lt;- seq(1,200,2) # 3 mymat[,3] &lt;- seq(2,200,2) # 4 매트릭스의 row나 column에 이름이 주어져 있을 경우 이름을 따옴표(\")로 묶은 후 참조가 가능합니다. row나 column의 이름은 rownames() 또는 colnames()로 생성하거나 변경할 수 있습니다. row나 column의 개수는 nrow() 또는 ncol() 함수를 사용합니다. colnames(mymat) colnames(mymat) &lt;- c(&quot;A&quot;, &quot;B&quot;, &quot;C&quot;) colnames(mymat) colnames(mymat)[2] &lt;- &quot;D&quot; colnames(mymat) rownames(mymat) &lt;- paste(&quot;No&quot;, 1:nrow(mymat), sep=&quot;&quot;) rownames(mymat) 여러 row나 column을 참조할 경우 아래와 같이 combine 함수를 사용하여 묶어줘야 하며 스칼라값을 (임의의 숫자 하나) 더하거나 뺄 경우 vector / matrix 연산을 기본으로 수행합니다. mymat[c(2,3,4,5),2] # 5 mymat-1 # 6 mysub &lt;- mymat[,2] - mymat[,1] #7 sum(mysub) #8 sum(mysub^2) #8 3.6.0.1 Exercise 3-4 score 라는 변수에 1부터 100까지 중 랜덤하게 선택된 20개의 수로 10 x 2 matrix를 만드시오 (sample() 사용) score의 row 이름을 문자형으로 Name1, Name2, …, Name10으로 지정하시오 (paste() 사용) score의 column 이름을 문자형으로 math와 eng로 지정하시오 이 matrix의 첫번째 컬럼과 두 번째 컬럼의 수를 각각 더한 후 total_score라는 변수에 저장하시오 total_score의의 오름차순 순서를 나타내는 인덱스 (order()함수 사용)를 o라는 변수에 저장하시오 score를 o순서로 재배치하고 score_ordered 변수에 저장하시오 3.7 Object - data.frame 데이터프레임은 형태는 매트릭스와 같으나 컬럼 하나가 하나의 변수로서 각 변수들이 다른 모드의 값을 저장할 수 있다는 차이가 있습니다. $ 기호를 이용하여 각 구성 변수를 참조할 수 있습니다. 컬럼 한 줄이 하나의 변수 이므로 새로운 변수도 컬럼 형태로 붙여 넣을 수 있습니다. 즉, 각 row는 샘플을 나타내고 각 column은 변수를 나타내며 각 변수들이 갖는 샘플의 개수 (row의 길이, vector 의 길이)는 같아야 합니다. R 기반의 데이터 분석에서는 가장 선호되는 데이터 타입이라고 볼 수 있습니다. ## data.frame ids &lt;- 1:10 ids idnames &lt;- paste(&quot;Name&quot;, ids, sep=&quot;&quot;) idnames students &lt;- data.frame(ids, idnames) students class(students$ids) class(students$idnames) students$idnames str(students) students &lt;- data.frame(ids, idnames, stringsAsFactors = F) class(students$idnames) students$idnames students[1,] str(students) 데이터프레임에서도 변수 이름으로 인덱싱이 가능합니다. ## data frame indexing students$ids students[,1] students[,&quot;ids&quot;] 3.7.0.1 Exercise 3-5 math라는 변수에 1부터 100까지 중 랜덤하게 선택된 10개의 수를 넣으시오 eng라는 변수에 1부터 100까지 중 랜덤하게 선택된 10개의 수를 넣으시오 students라는 변수에 문자형으로 Name1, Name2, …, Name10으로 지정하시오 (paste() 사용) math와 eng라는 벡터에 저장된 값들의 이름을 students 변수에 저장된 이름으로 지정하시오 math와 eng 벡터를 갖는 score 라는 data.frame을 만드시오 math와 eng 변수를 지우시오 (rm()사용) score data frame의 math와 eng를 각각 더한 후 total_score라는 변수에 저장 하시오 3.8 Object - list 리스트는 변수들의 모임이라는 점에서 데이터프레임과 같으나 구성 변수들의 길이가 모두 같아야 하는 데이터프레임과는 달리 다른 길이의 변수를 모아둘 수 있는 점이 다릅니다. 즉, R언어에서 두 변수를 담을 수 있는 데이터 타입은 list와 data frame 두 종류가 있는데 list 변수 타입은 vector 형태의 여러개의 element를 가질 수 있으며 각 vector의 길이가 모두 달라도 됩니다. list의 인덱싱에서 [ ]는 리스트를 반환하고 [[ ]]는 vector element들을 반환합니다. ## list parent_names &lt;- c(&quot;Fred&quot;, &quot;Mary&quot;) number_of_children &lt;- 2 child_ages &lt;- c(4, 7, 9) data.frame(parent_names, number_of_children, child_ages) lst &lt;- list(parent_names, number_of_children, child_ages) lst[1] lst[[1]] class(lst[1]) class(lst[[1]]) lst[[1]][1] lst[[1]][c(1,2)] 3.9 Missing values 특정 값이 “Not available” 이거나 “Missing value” 일 경우 벡터의 해당 원소 자리에 데이터의 이상을 알리기 위해 NA를 사용합니다. 따라서 일반적인 연산에서 NA가 포함되어 있는 경우 데이터의 불완전성을 알리기 위해 연산의 결과는 NA가 됩니다. is.na() 함수는 해당 변수에 NA 값이 있는지를 검사해주는 함수이며 R에는 이 외에도 다음과 같은 특수 값들이 사용되고 있습니다. NA: Not available, The value is missing NULL: a reserved value NaN: Not a number (0/0) Inf: (1/0) hip_cost &lt;- c(10500, 45000, 74100, NA, 83500) sum(hip_cost) sum(hip_cost, na.rm=TRUE) ?sum 3.10 Useful functions I 다음은 벡터형 변수와 같이 쓰이는 유용한 함수들입니다. z &lt;- sample(1:10, 100, T) head(z) sort(z) order(z) table(z) p &lt;- z/sum(z) round(p, digits=1) digits &lt;- as.character(z) n &lt;- as.numeric(digits) d &lt;- as.integer(digits) 이 저작물은 크리에이티브 커먼즈 저작자표시-비영리-변경금지 4.0 국제 라이선스에 따라 이용할 수 있습니다. "],["r-language-basics-ii-objects.html", "4 R language basics II - Objects 4.1 A script in R 4.2 Functions 4.3 Vectorized functions 4.4 if statements 4.5 ifelse statements 4.6 for, while, repeat 4.7 Avoiding Loops 4.8 Object Oriented Programming (Advanced)", " 4 R language basics II - Objects https://youtu.be/jYg88NoRc0A 4.1 A script in R R 프로그래밍을 통해서 사용자가 원하는 기능을 수행하는 방법은 다음과 같이 스크립트를 만들어서 실행하는 것 입니다. 일반적으로 R을 이용한 스크립트 명령을 어떻게 실행하는지 알아보겠습니다. 다음 예제는 입력 값들의 평균을 계산해서 출력해 주는 스크립트 명령입니다. R base 패키지에서 기본으로 제공되는 mean()이라는 함수가 있지만 사용하지 않고 sum()과 length() 함수를 사용했습니다. numbers &lt;- c(0.452, 1.474, 0.22, 0.545, 1.205, 3.55) cat(&quot;Input numbers are&quot;, numbers, &quot;\\n&quot;) numbers_mean &lt;- sum(numbers)/length(numbers) out &lt;- paste(&quot;The average is &quot;, numbers_mean, &quot;.\\n&quot;, sep=&quot;&quot;) cat(out) 상황에 따라 다르긴 하지만 보통 위 스크립트를 실행할 때 R 파일을 하나 만들고 source()라는 함수를 사용해서 파일 전체를 한번에 읽어들이고 실행을 시킵니다. 위 코드를 myscript.R 이라는 새로운 R 파일을 하나 만들고 저장 후 다음과 같이 실행할 수 있습니다. 참고로 위 파일은 현재 Working directory와 같은 위치에 저장해야 합니다. source(&quot;myscript.R&quot;) 그러나 위와 같은 식으로 실행할 경우 다음 몇 가지 문제가 있습니다. 하나는 입력 값이 바뀔 때마나 파일을 열어 바뀐 값을 저장해 줄 필요가 있습니다. 결과 값에 대해서 다른 처리를 하고 싶을 경우 또한 파일을 직접 수정해 주어야 합니다. 또한 모든 변수들이 전역변수로 사용되어 코드가 복잡해질 경우 변수간 간섭이 생길 가능성이 높습니다. 4.2 Functions 함수를 사용하면 위와같은 문제를 극복할 수 있습니다. 함수(Function)는 다음과 같은 포멧으로 구현할 수 있습니다. my_function_name &lt;- function(parameter1, parameter2, ... ){ ##any statements return(object) } 예를 들어 다음과 같은 my_sine 함수를 만들 수 있으며 parameter (매개변수)는 x이고 y는 반환값을 저장하는 지역변수 입니다. my_sine &lt;- function(x){ y &lt;- sin(x) return(y) } 만들어진 함수는 다음과 같이 사용할 수 있습니다. 만들어진 함수는 처음에 한 번 실행해 주어 실행중인 R session에 등록한 후 사용할 수 있습니다. 여기서 함수로 전달되는 값 pi는 argument (전달인자) 라고 합니다. 전달인자는 함수에서 정의된 매개변수의 갯수와 같은 수의 전달인자를 입력해 주어야 합니다. my_sine(pi) my_sine(90) sin(90) Terminology function name: my_sine parameter: x argument: pi return value: y 이제 위 스크립트 (‘myscript.R’) 에서 사용된 코드를 함수로 바꿔봅니다. numbers (전달인자)를 받는 매개변수를 x로 하고 함수 이름은 mymean 이고 평균값 (numbers_mean)을 반환하는 합수입니다. numbers &lt;- c(0.452, 1.474, 0.22, 0.545, 1.205, 3.55) mymean &lt;- function(x){ cat(&quot;Input numbers are&quot;, x, &quot;\\n&quot;) numbers_mean &lt;- sum(x)/length(x) out &lt;- paste(&quot;The average is &quot;, numbers_mean, &quot;.\\n&quot;, sep=&quot;&quot;) cat(out) return(numbers_mean) } retval &lt;- mymean(numbers) cat(retval) myscript.R이라는 파일을 열고 작성된 스크립트에 더해서 아래처럼 함수 코드를 만들 경우 source() 함수로 함수를 세션으로 읽어오고 바로 사용할 수 있습니다. 위와 같이 함수를 만들 경우 입력 값을 언제든 바꿔서 사용할 수 있고 반환값에 대한 추가적인 연산도 쉽게 수행 할 수 있습니다. new_values &lt;- c(1:10) retval &lt;- mymean(new_values) retval 4.2.1 Exercise 3-1 mysd라는 이름의 (표본)표준편차를 구하는 함수를 myscript.R 파일에 구현하시오 (sd()함수 사용하지 않고, 다음 표준편차 공식 이용) \\[ \\sigma = \\sqrt{\\frac{\\sum(x-mean(x))^2}{length(x)-1}} \\] 코드는 아래와 같음 mysd &lt;- function(x){ numbers_sd &lt;- sqrt(sum((x - mymean(x))^2)/(length(x)-1)) return(numbers_sd) } 1부터 100까지의 값을 x에 저장하고 mysd 함수를 사용해서 표준편차를 구하시오 x &lt;- 1:100 mysd(x) 앞서 작성한 mymean 함수와 mysd 함수를 같이 사용하여 x를 표준화 하고 z로 저장하시오. 표준화 공식은 다음과 같음 \\[ z = \\frac{x - mean(x)}{sd(x)} \\] z &lt;- (x - mymean(x))/mysd(x) x 와 z를 갖는 y라는 이름의 data.frame을 생성하시오 다음 코드를 보면 전역변수 x, y는 지역변수 x, y와 독립적으로 사용됨을 알 수 있습니다. my_half &lt;- function(x){ y &lt;- x/z cat(&quot;local variable x:&quot;, x, &quot;\\n&quot;) cat(&quot;local variable y:&quot;, y, &quot;\\n&quot;) cat(&quot;global variable z:&quot;, z, &quot;\\n&quot;) return(y) } y &lt;- 100 x &lt;- 20 z &lt;- 30 cat(&quot;Global variable x:&quot;, x, &quot;\\n&quot;) cat(&quot;Global variable y:&quot;, y, &quot;\\n&quot;) cat(&quot;Global variable z:&quot;, z, &quot;\\n&quot;) my_half(5) my_half &lt;- function(x, z){ y &lt;- x/z cat(&quot;local variable x:&quot;, x, &quot;\\n&quot;) cat(&quot;local variable y:&quot;, y, &quot;\\n&quot;) cat(&quot;local variable z:&quot;, z, &quot;\\n&quot;) return(y) } my_half(5, 10) log, sin등의 함수들은 Built-in function으로 같은 이름의 함수를 만들지 않도록 주의합니다. x &lt;- pi sin(x) sqrt(x) log(x) log(x, 10) x &lt;- c(10, 20, 30) x + x mean(x) sum(x)/length(x) 4.3 Vectorized functions 초기에 R이 다른 프로그래밍 언어에 비해서 경쟁력을 갖는 이유 중 하나가 바로 이 벡터 연산 기능 이였습니다. vector 변수에 들어있는 각 원소들에 대해서 특정 함수나 연산을 적용하고 싶을 경우 전통 방식의 C나 Java등의 언어에서는 원소의 개수만큼 반복문을 돌면서 원하는 작업을 수행 했습니다. 그러나 R의 벡터 연산 기능은 별도의 반복문 없이 vector 안에 있는 원소들에 대한 함수 실행 또는 연산을 수행할 수 있습니다. x &lt;- c(10, 20, 30) x + x sqrt(x) sin(x) log(x) x-mean(x) length(x) test_scores &lt;- c(Alice = 87, Bob = 72, James= 99) names(test_scores) 4.3.1 Exercise 3-2 다음은 한 다이어트 프로그램의 수행 전 후의 다섯 명의 몸무게이다. Before 78 72 78 79 105 after 67 65 79 70 93 각각을 before 와 after 이름의 변수에 저장 후 몸무게 값의 변화량을 계산하여 diff 라는 변수에 저장하시오 diff에 저장된 값들의 합, 평균, 표준편차를 구하시오 4.3.2 Exercise 3-3 다음 네 학생이 있으며 “John,”“James,”“Sara,” “Lilly” 각 나이는 21, 55, 23, 53 이다. ages 라는 변수를 생성하고 각 나이를 저장한 후 who라는 이름의 함수를 만들어서 50살 이상인 사람의 이름을 출력하는 함수를 만드시오. ages라는 변수에 나이 저장, c() 함수 이용, vector 형태 저장 names() 함수 이용해서 각 ages 벡터의 각 요소에 이름 붙이기 which() 함수 사용해서 나이가 50보다 큰 인덱스 찾고 해당 인덱스 값들을 idx에 저장 ages에서 idx에 해당하는 인덱스를 갖는 값을 sel_ages에 저장 names()함수를 이용해서 sel_ages의 이름을 sel_names에 저장 위 설명을 참고해서 input이라는 파라메터를 갖고 sel_names라는 50살 이상인 사람의 이름을 반환하는 who50이라는 이름의 함수 만들기 who50 함수의 사용법은 who50(ages) 임 4.4 if statements R에서의 제어문의 사용은 다른 프로그래밍 언어와 거의 유사합니다. 먼저 if 는 다음과 같은 형식으로 사용되며 () 안에 특정 조건 판단을 위한 표현이 들어갑니다. if(condition){ expr_1 }else{ expr_2 } 특히 condition은 하나의 원소에 대한 조건 판단문으로 T 또는 F 값 하나만을 반환하는 문장이어야 합니다. 위 코드는 만약 condition 조건이 True 이면 expr_1를 실행하고 False이면 expr_2를 실행하라는 명령입니다. condition 안에서 사용되는 비교 연산자들은 다음과 같습니다. x &lt;- 2 if(x%%2 == 1){ cat(&quot;Odd&quot;) }else{ cat(&quot;Even&quot;) } x &lt;- 5 if(x &gt; 0 &amp; x &lt; 4){ print(&quot;Positive number less than four&quot;) } if(x &gt; 0) print(&quot;Positive number&quot;) x &lt;- -5 if(x &gt; 0){ print(&quot;Non-negative number&quot;) } else if(x &lt;= 0 &amp; x &gt; -5){ print(&quot;Negative number greater than -5&quot;) } else { print(&quot;Negative number less than -5&quot;) } if(x &gt; 0) print(&quot;Non-negative number&quot;) else print(&quot;Negative number&quot;) 4.5 ifelse statements if는 하나의 조건만 비교하는데 사용할 수 있습니다. 그러나 변수에는 여러 값이 벡터형식으로 들어가고 벡터연산을 수행할 경우의 결과도 벡터형식으로 나오지만 if문은 이들을 한 번에 처리하기 어렵습니다. ifelse는 이러한 단점을 보완하여 여러 값을 한번에 처리할 수 있습니다. ifelse (condition, True일 때 리턴값, False일 때 리턴값) x &lt;- c(1:10) if(x&gt;10){ cat(&quot;Big&quot;) }else{ cat(&quot;Small&quot;) } ifelse(x&gt;10, &quot;Big&quot;, &quot;Small&quot;) 그러나 출력만 가능하며 조건별로 다른 명령 수행은 불가능하다는 단점이 있습니다. 4.5.1 Exercise 3-4 다음은 median (중간값)을 구하는 공식이며 x의 길이가 (n이) 홀수일 경우와 짝수일 경우에 따라서 다른 공식이 사용된다. 다음 공식과 코드를 이용하여 mymedian 이라는 이름의 함수를 만들고 입력 값들의 중간값을 구해서 반환하는 함수를 만드시오. (%% 나머지 연산, if문 사용, 아래 중간값 코드 참고) \\[ median(X) = \\begin{cases} \\frac{1}{2} X[\\frac{n}{2}] + \\frac{1}{2} X[1+\\frac{n}{2}] &amp; \\mbox{if } n \\mbox{ is even} \\\\ X[\\frac{n+1}{2}] &amp; \\mbox{if } n \\mbox{ is odd} \\end{cases} \\] sorted_x &lt;- sort(x) # 만약 짝수이면 retval &lt;- sort_x[n/2]/2 + sort_x[1+(n/2)]/2 # 만약 홀수이면 retval &lt;- sort_x[(n+1)/2] 4.6 for, while, repeat for 문은 반복적으로 특정 코드를 실행하고자 할 때 사용됩니다. 다음과 같은 형식으로 사용할 수 있습니다. for(var in seq){ expression } var는 반복을 돌 때마다 바뀌는 변수로 {} 안에서 사용되는 지역 변수 입니다. seq는 vector 형식의 변수로 반복을 돌 때마다 순차적으로 var에 저장되는 값들 입니다. x &lt;- 1:10 for(i in x){ cat(i, &quot;\\n&quot;) flush.console() } sum_of_i &lt;- 0 for(i in 1:10){ sum_of_i &lt;- sum_of_i + i cat(i, &quot; &quot;, sum_of_i, &quot;\\n&quot;);flush.console() } while문도 for문과 같이 반복적으로 특정 코드를 수행하고자 할 때 사용합니다. 사용하는 문법은 다음과 같으며 cond는 True 또는 False 로 반환되는 조건문을 넣고 True 일 경우 계속해서 반복하면서 expressions를 수행하며 이 반복은 cond가 False로 될 때 까지 계속됩니다. while(cond){ expression } while문을 사용할 경우 다음과 같이 indicator라 불리우는 변수를 하나 정해서 반복 할 때마다 값이 바뀌도록 해 주어야 합니다. 그렇지 않으면 무한 루프를 돌게 되는 문제가 발생합니다. i &lt;- 10 f &lt;- 1 while(i&gt;1){ f &lt;- i*f i &lt;- i-1 cat(i, f, &quot;\\n&quot;) } f factorial(10) repeat 명령은 조건 없이 블럭 안에 있는 코드를 무조건 반복하라는 명령 입니다. 따라서 블럭 중간에 멈추기 위한 코드가 필요하고 이 명령이 break 입니다. repeat{ expressions if(cond) break } i &lt;- 10 f &lt;- 1 repeat { f &lt;- i*f i &lt;- i-1 cat(i, f, &quot;\\n&quot;) if(i&lt;1) break } f factorial(10) 4.7 Avoiding Loops R에서는 가능하면 loop문을 사용하지 않는 것이 좋습니다. 이는 다른 언어들 보다 반복문이 느리게 수행된다는 이유 때문이기도 합니다. 그러나 R에서는 반복문을 수행하는 것 보다 훨씬 더 빠르게 반복문을 수행 한 것과 같은 결과를 얻을 수 있는 다양한 방법들이 제공되고 있습니다. 차차 그런 기법들에 대한 학습을 진행하도록 하겠습니다. x &lt;- 1:1E7 sum(x) system.time(sum(x)) st &lt;- proc.time() total &lt;- 0 for(i in 1:length(x)){ total &lt;- total + x[i] } ed &lt;- proc.time() ed-st 4.8 Object Oriented Programming (Advanced) OOP는 객체지향 프로그래밍 이라고 합니다. OOP를 이용해서 프로그래밍으로 풀고자 하는 문제를 좀 더 명확하게 개념을 수립하고 복잡한 코드를 명료하게 만들 수 있습니다. 그런데 R에서 OOP는 다른 언어보다는 좀 더 어려운 개념적인 이해가 필요합니다. S3, S4, 그리고 Reference class 가 있으며 S3, S4는 Generic function을 이용하며 다른 언어에서 사용하는 OOP 개념과는 다릅니다. Reference class는 다른 언어에서 사용하는 OOP 개념과 유사하며 R6 패키지를 이용해서 사용할 수 있습니다. 이 저작물은 크리에이티브 커먼즈 저작자표시-비영리-변경금지 4.0 국제 라이선스에 따라 이용할 수 있습니다. "],["rdataioandtransformation.html", "5 Data I/O and transformation 5.1 Loading data into R 5.2 writing data into a text file 5.3 Excel file read 5.4 subset 5.5 merging and split 5.6 transforming data 5.7 Analysis example (babies dataset)", " 5 Data I/O and transformation 일반적인 데이터 분석은 데이터 전처리(변환), 가시화, 모델링(통계분석)의 반복적인 수행으로 진행될 수 있습니다. R에서는 data.frame 형식의 데이터 타입이 주로 사용되며 (최근 tibble형식) 따라서 data.frame 기반의 데이터를 다루기 위한 다양한 함수를 익힐 필요가 있습니다. 이번 강의에서는 data.frame 데이터를 읽거나 쓰는 함수들과 함께 데이터 전처리를 (변환) 위한 함수들을 배워보겠습니다. 앞에서 배웠던 데이터를 저장하는 object의 종류를 먼저 간략히 정리해 봅니다. Vectors - 같은 타입의 데이터를 (Numeric, character, factor, …) 저장한 오브젝트 타입으로 인덱스는 [, ] 사용. Lists - 여러개의 vector를 원소로 가질 수 있으며 이 원소들은 문자나 숫자 어떤 데이터 타입도 가능하고 길이가 달라도 됨. list의 인덱싱에서 [ ]는 리스트를 반환하고 [[ ]]는 vector를 반환함. Matrices - 같은 타입의 데이터로 채워진 2차원 행렬이며 인덱스는 [i, j] 형태로 i는 row, j는 column 을 나타냄. 메트릭스의 생성은 matrix 명령어를 사용하며 왼쪽부터 column 값을 모두 채우고 다음 컬럼 값을 채워 나가는 것이 기본 설정이며 byrow=T 를 통해 row를 먼저 채울수도 있음. row와 column 이름은 rownames와 colnames로 설정이 가능하며 rbind와 cbind로 두 행렬 또는 행렬과 백터를 연결할 수 있음 ( rbind와 cbind의 경우 행렬이 커지면 컴퓨터 리소스 많이 사용함) data.frame - list와 matrix의 특성을 모두 갖는 오브젝트 타입으로 list와 같이 다른 타입의 vector형 변수 여러개가 컬럼에 붙어서 matrix 형태로 구성됨. 단, list와는 다르게 각 변수의 길이가 (row의 길이) 같아야 함. $ 기호로 각 변수들을 인덱싱(접근) 할 수 있고 matrix와 같이 [i,j] 형태의 인덱싱도 가능. 5.1 Loading data into R 데이터 분석을 위해서 가장 먼저 할 일은 데이터를 R로 읽어들이는 것 입니다. Bioinformatics Data Skills by Vince Buffalo의 Chapter 8에서 소개한 데이터 중 일부인 Dataset_S1_sub.txt를 이용하겠습니다. 대부분의 텍스트 파일은 아래와 같이 csv 또는 txt 파일로 저장하여 메모장으로 열어 확인할 수 있으며 읽어올 때 구분자 (sep 파라메터) 나 header를 (header 파라메터) 읽을지 등을 옵션으로 지정할 수 있습니다. dat &lt;- read.csv(&quot;Dataset_S1_sub.txt&quot;) head(dat) Dataset_S1_sub.txt 파일을 열어보면 다음과 같이 header와 “,”로 구분되어 있는 것을 볼 수 있습니다. read.csv 함수의 도움말을 보면 이 함수의 파라메터 head와 sep이 기본값으로 T와 ,로 되어 있는 것을 볼 수 있습니다. read.csv 외에도 read.table, read.delim 등의 함수를 이용해서 택스트 파일을 읽어올 수 있습니다. str(dat) 참고로 위 데이터는 wide형 데이터 입니다. wide형 데이터는 일반적인 excel에서의 데이터 형태로 column은 변수, row는 샘플이 저장됩니다. 만약 새로운 변수가 추가 되면 column 오른쪽에 붙어 wide하게 확장되고 데이터(샘플)이 추가되면 아래에 붙어서 row가 추가 됩니다. 출처: Bioinformatics Data Skills by Vince Buffalo 반면 long 형 데이터는 아래와 같이 일반적으로 3개의 컬럼을 갖습니다. 이 경우 변수든 샘플이든 새로운 데이터가 추가될 경우 아래로 확장됩니다. wide형과 long형에 대한 추가 설명은 다음 강의에서 진행하도록 하겠습니다. 출처: Bioinformatics Data Skills by Vince Buffalo 5.2 writing data into a text file 읽어들이거나 분석한 결과에 대한 데이터는 write.table 또는 write.csv 함수를 사용하여 텍스트 파일의 형태로 저장할 수 있습니다. 이 경우 알아둘 파라메터는 quote, row.names, col.names, sep 등이 있습니다. write.table(dat, file=&quot;table_write.txt&quot;) write.table(dat, file=&quot;table_write.txt&quot;, quote=F) write.table(dat, file=&quot;table_write.txt&quot;, quote=F, row.names=F) write.table(dat, file=&quot;table_write.txt&quot;, quote=F, row.names=F, sep=&quot;,&quot;) write.table(dat, file=&quot;table_write.csv&quot;, quote=F, row.names=F, sep=&quot;,&quot;) 5.3 Excel file read 텍스트 파일 외에 엑셀파일은 readxl 이라는 R 패키지를 활용하여 읽거나 쓸 수 있습니다. 패키지는 다음과 같은 방법으로 설치할 수 있으며 read_excel 이라는 함수를 사용해서 데이터를 읽어들일 수 있습니다. install.packages(&quot;readxl&quot;) library(readxl) 실습 파일은 형광 세포를 배양하여 형광리더기를 이용해 얻어진 실제 데이터이며 Exp_data.xls 에서 다운로드 받을 수 있습니다. read_excel 함수를 이용하여 파일의 내용을 읽어오면 기본 자료형이 tibble 입니다. tibble은 최근 많이 쓰이는 R object로 data.frame과 유사하나 입력값의 type, name, rowname을 임으로 바꿀 수 없다는 점이 다릅니다. dat &lt;- read_excel(&quot;Exp_data.xls&quot;, sheet=1, skip = 0, col_names=T) 엑셀파일에는 두 종류의 (\\(OD600_{nm}\\), Fluorescence) 데이터가 저장되어 있습니다. 첫 번째 sheet에는 다음처럼 wide형 데이터가 저장되어 있습니다. 5.4 subset R에서 데이터 저장은 data.frame이나 matrix 타입을 일반적으로 사용합니다. 이 데이터의 일부 열 또는 행의 데이터만을 가져와서 별도로 저장하거나 분석이 필요할 경우가 있습니다. 이 때 인덱싱을 사용해서 일부 데이터를 선택하고 사용할 수 있으며 subset 함수도 이러한 선별 기능을 제공합니다. subset은 행과 열 모두를 선별할 수 있는 함수입니다. 다음 airquality 데이터는 1973년 날짜별로 뉴욕의 공기질을 측정한 데이터 입니다. NA를 제외한 나머지 데이터만으로 새로운 데이터셋을 만들어 봅시다. is.na함수를 사용하면 해당 데이터가 NA일 경우 TRUE, NA가 아닐 경우 FALSE 를 반환해 줍니다. is.na(airquality$Ozone) ozone_complete1 &lt;- airquality[!is.na(airquality$Ozone),] ozone_complete1 &lt;- subset(airquality, !is.na(Ozone)) 위 ozone_complete1와 ozone_complete2는 같은 결과를 보입니다. 그러나 ozone_complete1 보다는 ozone_complete2 코드가 훨씬 직관적이고 가독성이 높습니다. 특히 airquality$ozone 로 $를 사용하여 변수에 접근한 것이 아닌 Ozone이라는 변수 이름을 직접 사용해서 접근함으로써 코드의 간결성과 가독성을 유지할 수 있습니다. 또한 subset의 select 옵션을 이용해서 변수를 선택할 수도 있으며 &amp;(AND)와 |(OR) 연산자를 사용해서 조건을 두 개 이상 설정할 수 있습니다. 아래 select 옵션에서 -는 해당 변수를 제외한다는 의미 입니다. ozone_complete3 &lt;- subset(airquality, !is.na(ozone), select=c(ozone, temp, month, day)) ozone_complete4 &lt;- subset(airquality, !is.na(ozone) &amp; !is.na(solar.r), select=c(-month, -day)) 5.4.1 Exercise 7.1 airquality 데이터에서 Temp와 Ozone 변수로 이루어진 df라는 이름의 data.frame을 만드시오 (단 NA가 있는 샘플(열)은 모두 제외하시오) 5.5 merging and split merge 함수는 두 개 이상의 데이터셋을 통합하는 기능을 수행하는 함수입니다. 특히 rbind나 cbind와는 다르게, 결합하는 두 데이터에 공통적이거나 한 쪽의 데이터를 기준으로 결합을 수행 합니다. ?merge를 참고하면 by, by.x, by.y, all, all.x, all.y 등의 옵션으로 이러한 설정을 수행할 수 있습니다. 간단한 예제를 통해서 이해해 보겠습니다. 10명의 사람이 있고 이 사람들의 나이와 성별을 각각 나타낸 두 데이터셋이 있습니다. 그런데 df1은 나이만을 df2는 성별 정보만을 가지고 있으며 두 정보 모두 제공된 사람은 3명 (인덱스 4,5,6) 뿐입니다. 이제 merge를 이용해서 두 데이터셋을 결합해 보겠습니다. ## merge df1 &lt;- data.frame(id=c(1,2,3,4,5,6), age=c(30, 41, 33, 56, 20, 17)) df2 &lt;- data.frame(id=c(4,5,6,7,8,9), gender=c(&quot;f&quot;, &quot;f&quot;, &quot;m&quot;, &quot;m&quot;, &quot;f&quot;, &quot;m&quot;)) df_inner &lt;- merge(df1, df2, by=&quot;id&quot;, all=F) df_outer &lt;- merge(df1, df2, by=&quot;id&quot;, all=T) df_left_outer &lt;- merge(df1, df2, by=&quot;id&quot;, all.x=T) df_right_outer &lt;- merge(df1, df2, by=&quot;id&quot;, all.y=T) 만약 두 데이터셋의 id가 다를 경우나 각각 다른 기준으로 결합해야 하는 경우는 by대신 by.x, by.y 옵션을 사용할 수 있습니다. split 함수는 데이터를 특정 기준으로 나누는 역할을 하며 해당 기준은 factor 형 벡터 형태로 주어질 수 있습니다. 예를 들어 airquality 데이터의 month 변수를 기준으로 데이터를 분리해 보겠습니다. str(airquality) g &lt;- factor(airquality$Month) airq_split &lt;- split(airquality, g) class(airq_split) str(airq_split) 위와 같이 airq_split은 길이가 5인 (5, 6, 7, 8, 9월) list타입이 되었고 각 요소는 서로 다른 size의 data.frame형으로 구성 된 것을 확인할 수 있습니다. 5.6 transforming data R에서 기존 가지고 있는 데이터의 변경은 새로운 변수의 추가, 삭제, 변형과 샘플의 추가, 삭제, 변형을 생각해 볼 수 있습니다. 이러한 기능은 앞에서 배운 merge, split이나 rbind, cbind, 그리고 인덱싱을 활용한 값 변경 등의 방법을 이용할 수 있습니다. 또한 가장 직관적으로 필요한 변수들을 기존 데이터셋에서 추출한 후 data.frame 명령어를 사용해서 새로운 데이터셋으로 만들어주면 될 것 입니다. 이러한 방법들 외에 within을 사용할 경우 특정 변수의 변형과 이를 반영한 새로운 데이터셋을 어렵지 않게 만들수 있습니다. with 함수의 사용 예와 함께 within 함수를 사용하여 데이터를 변형하는 예를 살펴봅니다. with나 within 함수는 R을 활용하는데 많이 사용되는 함수들은 아닙니다. 또한 이러한 기능들은 dplyr 등의 패키지에서 제공하는 경우가 많아서 필수적으로 익힐 부분은 아닙니다. 그러나 개념적인 이해를 돕기위한 좋은 도구들이며 여전히 고수준의 R 사용자들이 코드에 사용하고 있는 함수들이므로 알아두는 것이 좋습니다. ## without with ozone_complete &lt;- airquality[!is.na(airquality$Ozone),&quot;Ozone&quot;] temp_complete &lt;- airquality[!is.na(airquality$Temp),&quot;Temp&quot;] print(mean(ozone_complete)) print(mean(temp_complete)) ## with with(airquality, { print(mean(Ozone[!is.na(Ozone)])) print(mean(Temp[!is.na(Temp)])) }) 위 with 함수에서 보는바와 같이 $를 이용한 변수 접근 대신 with함수 내에서는 ({, } 안에서) 해당 data.frame에 있는 변수 이름을 직접 접근할 수 있으며 따라서 코드의 간결함과 가독성이 향상됩니다. within 함수는 with함수와 같이 {, } 안에서 변수의 이름만으로 해당 변수에 접근이 가능하나 입력된 데이터와 변경된 변수(들)을 반환한다는 점이 다릅니다. 아래 예는 airquality 데이터의 화씨 (Fahrenheit) 온도를 섭씨 (Celsius) 온도로 변환해서 새로운 데이터셋을 만드는 코드입니다. data.frame을 이용한 코드와 비교해 보시기 바랍니다. 데이터셋 내에서 참조할 변수들이 많아질 경우 airquality$xxx 식의 코드를 줄이는 것 만으로도 코드의 가독성과 간결성을 유지할 수 있습니다. newairquality &lt;- within(airquality, { celsius = round((5*(Temp-32))/9, 2) }) head(newairquality) ## data.frame celsius &lt;- round((5*(airquality$Temp-32))/9, 2) newairquality &lt;- data.frame(airquality, celsius) head(newairquality) 5.7 Analysis example (babies dataset) UsingR 패키지의 babies 데이터를 이용해서 산모의 흡연 여부와 신생아 몸무게의 관계를 알아보는 분석을 수행해 보겠습니다. 본 강의를 통해 배우지 않은 내용들이 있지만 코드를 따라 가면서 참고하시기 바랍니다. 우선 UsingR 패키지를 로딩합니다. 산모의 임신 기간이 (gestation) 999로 표기된 데이터는 명백히 에러이며 이들을 NA로 처리합니다. library(UsingR) library(ggplot2) head(babies) ## a simple way to checkout the data plot(babies$gestation) babies$gestation[babies$gestation&gt;900] &lt;- NA str(babies) 아래와 같이 within 함수를 사용해서 babies$ 를 반복해서 입력해주는 불편함을 줄이고 가독성을 높입니다. 똑같은 방법으로 dwt (아빠의 몸무게) 변수의 에러값들에 대해서도 NA 처리를 할 수 있습니다. new_babies &lt;- within(babies, { gestation[gestation==999] &lt;- NA dwt[dwt==999] &lt;- NA }) str(new_babies) smoke 변수는 흡연 여부를 나타내는 범주형 변수로 0, 1, 2, 3 값은 의미가 없습니다. 사람이 읽을 수 있는 label을 붙인 factor 형 변수로 변환하는 코드도 함께 작성해 보겠습니다. str(babies$smoke) new_babies &lt;- within(babies, { gestation[gestation==999] &lt;- NA dwt[dwt==999] &lt;- NA smoke = factor(smoke) levels(smoke) = list( &quot;never&quot; = 0, &quot;smoke now&quot; = 1, &quot;until current pregnancy&quot; = 2, &quot;once did, not now&quot; = 3) }) str(new_babies$smoke) 이제 임신기간과 흡연 여부를 분석해 볼 수 있습니다. 흡연 그룹별로 기간에 차이가 있는지를 알아보는 분석은 t-test나 ANOVA를 사용할 수 있습니다. fit &lt;- lm(gestation~smoke, new_babies) summary(fit) ## t-test 결과 anova(fit) 간단히 결과를 보면 summary(fit)은 3가지 t-test의 결과를 보여줍니다. never vs. smoke new 의 경우 t값이 -1.657로 피우지 않은 경우에 비해서 피우는 사람의 임신 기간이 유의하게 줄어들었음을 알 수 있습니다. 그에 비해서 현재 흡연하지 않는 경우 (never vs. until current pregnancy 또는 never vs. once did, not now) 차이가 없는 것으로 나옵니다. 이제 smoke now 인 경우 또는 나이가 25세 미만인 경우의 샘플에 대해서 newdf를 만들어 봅니다 (subset 함수 사용, id, gestation, age, wt, smoke 변수 선택). 이 후 ggplot을 이용하여 몸무게와 임신기간의 산점도를 그려보면 크게 다르진 않으나 흡연하는 여성 중 몸무게가 적게 나가는 여성에게서 짧은 임신기간을 갖는 경향을 볼 수 있습니다. newdf &lt;- subset(new_babies, (smoke==&quot;smoke now&quot; | smoke == &quot;never&quot;) &amp; age &lt; 25, select=c(id, gestation, age, wt, smoke)) # ggplot(newdf, aes(x=wt, y=gestation, color=smoke)) + # geom_point(size=3, alpha=0.5) + # facet_grid(.~smoke) + # theme_bw() 이 저작물은 크리에이티브 커먼즈 저작자표시-비영리-변경금지 4.0 국제 라이선스에 따라 이용할 수 있습니다. "]]
